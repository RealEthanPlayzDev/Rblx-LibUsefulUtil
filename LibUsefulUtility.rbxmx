<roblox version="4">
  <Item class="ModuleScript" referent="0">
    <Properties>
      <string name="Name">LibUsefulUtil</string>
      <string name="Source">--[[
File name: LibUsefulUtility.lua
Author: RadiatedExodus (RealEthanPlayz)
--]]

local ct = {}
for _, v in ipairs(script:GetChildren()) do
	ct[v.Name] = v
end
return setmetatable(ct, {
	__newindex = function() end,
	__call = function(t, utilname)
		if t[utilname] then
			return require(t[utilname])
		end
		return false
	end,
	__metatable = "This metatable is locked"
})</string>
    </Properties>
    <Item class="ModuleScript" referent="1">
      <Properties>
        <string name="Name">LibCustomEvent</string>
        <string name="Source">--[[
File name: LibCustomEvent.lua
Author: RadiatedExodus (RealEthanPlayz/RealEthanPlayzDev/ItzEthanPlayz_YT)
--]]

local LibCustomEvent = {}
local LibCustomEventConnected = {}
LibCustomEvent.__index = LibCustomEvent
LibCustomEventConnected.__index = LibCustomEventConnected

LibCustomEvent.__metatable = "The metatable is locked"
LibCustomEventConnected.__metatable = "The metatable is locked"

--// LibCustomEvent class
--// function &lt;void> LibCustomEvent:Fire(... : variant)
function LibCustomEvent:Fire(...)
    assert(not self.isDestroyed, [[LibCustomEvent: this event has been destroyed and no longer can be used]])
    for _, v in ipairs(self.events) do
        if not typeof(v) == "function" then continue end
        local temp = {...}
        spawn(function() 
            v(unpack(temp))
        end)
    end
    return
end

--// function &lt;void> LibCustomEvent:FireSync(... : variant)
function LibCustomEvent:FireSync(...)
    assert(not self.isDestroyed, [[LibCustomEvent: this event has been destroyed and no longer can be used]])
    for _, v in ipairs(self.events) do
        if not typeof(v) == "function" then continue end
        v(...)
    end
    return
end

--// [alias of: LibCustomEvent:Fire(...)] function &lt;void> LibCustomEvent:FireAsync(... : variant)
function LibCustomEvent:FireAsync(...)
    return LibCustomEvent:Fire(...)
end

--// function &lt;LibCustomEventConnected> LibCustomEvent:Connect(func: function)
function LibCustomEvent:Connect(func)
    assert(not self.isDestroyed, [[LibCustomEvent: this event has been destroyed and no longer can be used]])
    assert(typeof(func) == "function", [[LibCustomEvent: invalid argument #1 to 'Connect' (function expected, got ]]..typeof(func)..[[)]])
    local selindex = #self.events + 1
    table.insert(self.events, selindex, func)
    return LibCustomEventConnected.new(self, selindex)
end

--// [deconstructor] function &lt;void> LibCustomEvent:Destroy()
function LibCustomEvent:Destroy()
    self.isDestroyed = true
    table.clear(self.events)
    return
end

--// LibCustomEventConnected class
--// [internal class usage]
function LibCustomEventConnected.new(eventinst, index)
    local newconnectedevent = setmetatable({}, LibCustomEventConnected)

    newconnectedevent.eventinst = eventinst
    newconnectedevent.currentindex = index
    newconnectedevent.Connected = true

    return newconnectedevent
end

--// function &lt;void> LibCustomEventConnected:Disconnect()
function LibCustomEventConnected:Disconnect()
    table.remove(self.eventinst.events, self.currentindex)
    self.Connected = false
    return
end

return {
    --// constructor
	new = function()
		local newevent = setmetatable({}, LibCustomEvent)

		newevent.events = {}
		newevent.isDestroyed = false

		return newevent
	end
}</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="2">
      <Properties>
        <string name="Name">LibDeviceInfo</string>
        <string name="Source">--[[
File name: DeviceInfo.lua
Author: RadiatedExodus (RealEthanPlayz/RealEthanPlayzDev/ItzEthanPlayz_YT)
Reference links:
- https://realethanplayzdev.github.io/Device%20Info/Device%20Info/
- https://www.roblox.com/library/5343169924/Device-Info
- https://devforum.roblox.com/t/device-info-LibDeviceInfo-to-detect-devices-platform-type-etc/716491
NOTES:
- This was originally an old LibDeviceInfo I made at July 2020, original links are posted on the reference links above.
- The account I used to post the Roblox DevForum post of DeviceInfo was terminated from the DevForum due to a mistake I made, I hope I will never do something like that again...
- The old API Reference on my page no longer matches this version (as I have rewritten this module), please do not use the API reference from there and wait until I remake my website.
    --]]

local LibDeviceInfo = {}
assert(not game:GetService("RunService"):IsServer(), "[DeviceInfo]: DeviceInfo can only be used to the server.")

local serv = {
    UserInputService = game:GetService("UserInputService");
    GuiService = game:GetService("GuiService")
}

local previnput, prevres, prevorientation, prevquality

local inputChanged = Instance.new("BindableEvent")
local resolutionChanged = Instance.new("BindableEvent")
local orientationChanged = Instance.new("BindableEvent")
local graphicsQualityChanged = Instance.new("BindableEvent")

--// Custom Enum creation
LibDeviceInfo.Enum = setmetatable({
	PlatformType = {
		Computer = "PlatformType_Computer",
		Console = "PlatformType_Console",
		Mobile = "PlatformType_Mobile"
	},
	InputType = {
		Touchscreen = "InputType_Touchscreen",
		KeyboardMouse = "InputType_KeyboardMouse",
		Gamepad = "InputType_Gamepad",
		VR = "InputType_VR",
		Keyboard = "InputType_Keyboard",
		Mouse = "InputType_Mouse"
	},
	DeviceType = {
		Computer = "DeviceType_Computer",
		Phone = "DeviceType_Phone",
		Tablet = "DeviceType_Tablet",
		Console = "DeviceType_Console",
		TouchscreenComputer = "DeviceType_TouchscreenComputer"
	},
	DeviceOrientation = {
		Landscape = "DeviceOrientation_Landscape",
		Portrait = "DeviceOrientation_Portrait"
	}
}, { __newindex = function() end; __metatable = "The metatable is locked"; })

--// function &lt;Vector2> LibDeviceInfo.GetRobloxWindowResolution()
function LibDeviceInfo.GetRobloxWindowResolution()
	prevres = Vector2.new(game.Workspace.CurrentCamera.ViewportSize.X, game.Workspace.CurrentCamera.ViewportSize.Y)
	return prevres
end

--// function &lt;PlatformType> LibDeviceInfo.GetDevicePlatform()
function LibDeviceInfo.GetDevicePlatform()
	if serv.GuiService:IsTenFootInterface() and serv.UserInputService.GamepadEnabled and not serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled then
		return LibDeviceInfo.Enum.PlatformType.Console
	elseif serv.UserInputService.TouchEnabled and not serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled then
		return LibDeviceInfo.Enum.PlatformType.Mobile
	else
		return LibDeviceInfo.Enum.PlatformType.Computer
	end
end

--// function &lt;InputType> LibDeviceInfo.GetDeviceInput()
function LibDeviceInfo.GetDeviceInput()
    --// KeyboardMouse
	if serv.UserInputService.KeyboardEnabled and serv.UserInputService.MouseEnabled and not serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		previnput = LibDeviceInfo.Enum.InputType.KeyboardMouse
		return LibDeviceInfo.Enum.InputType.KeyboardMouse
	
    --// Keyboard
	elseif serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled and not serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		previnput = LibDeviceInfo.Enum.InputType.Keyboard
		return LibDeviceInfo.Enum.InputType.Keyboard
		
    --// Mouse
	elseif not serv.UserInputService.KeyboardEnabled and serv.UserInputService.MouseEnabled and not serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		previnput = LibDeviceInfo.Enum.InputType.Mouse
		return LibDeviceInfo.Enum.InputType.Mouse
		
    --// Gamepad
	elseif not serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled and serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		previnput = LibDeviceInfo.Enum.InputType.Gamepad
		return LibDeviceInfo.Enum.InputType.Gamepad
		
    --// VR
	elseif serv.UserInputService.VREnabled then
		previnput = LibDeviceInfo.Enum.InputType.VR
		return LibDeviceInfo.Enum.InputType.VR
		
    --// Touchscreen
	else
		previnput = LibDeviceInfo.Enum.InputType.Touchscreen
		return LibDeviceInfo.Enum.InputType.Touchscreen
	end
end

--// function &lt;DeviceOrientation> LibDeviceInfo.GetDeviceOrientation()
function LibDeviceInfo.GetDeviceOrientation()
	if LibDeviceInfo.GetDevicePlatform() ~= LibDeviceInfo.Enum.PlatformType.Mobile then return end
	local isPortrait = game.Workspace.Camera.ViewportSize.X &lt; game.Workspace.Camera.ViewportSize.Y
	if isPortrait then
		return LibDeviceInfo.Enum.DeviceOrientation.Portrait
	else
		return LibDeviceInfo.Enum.DeviceOrientation.Landscape
	end
end

--// function &lt;DeviceType> LibDeviceInfo.GetDeviceType()
function LibDeviceInfo.GetDeviceType()
    --// Console
	if serv.GuiService:IsTenFootInterface() and serv.UserInputService.GamepadEnabled and not serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled then
		return LibDeviceInfo.Enum.DeviceType.Console
		
    --// Tablet/Phone
	elseif not serv.GuiService:IsTenFootInterface() and serv.UserInputService.TouchEnabled and not serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled then
		local deviceOrientation = LibDeviceInfo.GetDeviceOrientation()
		if deviceOrientation == LibDeviceInfo.Enum.DeviceOrientation.Landscape then
			
			if workspace.CurrentCamera.ViewportSize.Y &lt; 600 then
				return LibDeviceInfo.Enum.DeviceType.Phone
            end
			return LibDeviceInfo.Enum.DeviceType.Tablet
		elseif deviceOrientation ==  LibDeviceInfo.Enum.DeviceOrientation.Portrait then
			if workspace.CurrentCamera.ViewportSize.X &lt; 600 then
				return LibDeviceInfo.Enum.DeviceType.Phone
            end
			return LibDeviceInfo.Enum.DeviceType.Tablet
		end
		
    --// TouchscreenComputer
	elseif serv.UserInputService.TouchEnabled and serv.UserInputService.KeyboardEnabled and serv.UserInputService.MouseEnabled then
		return LibDeviceInfo.Enum.DeviceType.TouchscreenComputer
		
    --// Computer
	else
		return LibDeviceInfo.Enum.DeviceType.Computer
	end
end

--// function &lt;QualityLevel> LibDeviceInfo.GetGraphicsQuality()
function LibDeviceInfo.GetGraphicsQuality()
	return UserSettings().GameSettings.SavedQualityLevel
end

serv.UserInputService.LastInputTypeChanged:Connect(function()
	--// KeyboardMouse
	if serv.UserInputService.KeyboardEnabled and serv.UserInputService.MouseEnabled and not serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		if previnput == LibDeviceInfo.Enum.InputType.KeyboardMouse then return end
		inputChanged:Fire(LibDeviceInfo.Enum.InputType.KeyboardMouse)
		
    --// Keyboard
	elseif serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled and not serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		if previnput == LibDeviceInfo.Enum.InputType.Keyboard then return end
		inputChanged:Fire(LibDeviceInfo.Enum.InputType.Keyboard)
		
    --// Mouse
	elseif not serv.UserInputService.KeyboardEnabled and serv.UserInputService.MouseEnabled and not serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		if previnput == LibDeviceInfo.Enum.InputType.Mouse then return end
		inputChanged:Fire(LibDeviceInfo.Enum.InputType.Mouse)
		
    --// Gamepad
	elseif not serv.UserInputService.KeyboardEnabled and not serv.UserInputService.MouseEnabled and serv.UserInputService.GamepadEnabled and not serv.UserInputService.TouchEnabled then
		if previnput == LibDeviceInfo.Enum.InputType.Gamepad then return end
		inputChanged:Fire(LibDeviceInfo.Enum.InputType.Gamepad)
		
    --// VR
	elseif serv.UserInputService.VREnabled then
		if previnput == LibDeviceInfo.Enum.InputType.VR then return end
		inputChanged:Fire(LibDeviceInfo.Enum.InputType.VR)

	--// Touchscreen
	else
		if previnput == LibDeviceInfo.Enum.InputType.Touchscreen then return end
		inputChanged:Fire(LibDeviceInfo.Enum.InputType.Touchscreen)
	end
end)

local oldcamsignal = nil

workspace:GetPropertyChangedSignal("CurrentCamera"):Connect(function()
    if oldcamsignal then
        oldcamsignal:Disconnect()
        oldcamsignal = nil 
    end
    oldcamsignal = workspace.CurrentCamera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
        --// Size changed
        if game.Workspace.CurrentCamera.ViewportSize.X ~= prevres.X and game.Workspace.CurrentCamera.ViewportSize.X ~= prevres.Y then
            prevres = Vector2.new(game.Workspace.CurrentCamera.ViewportSize.X, game.Workspace.CurrentCamera.ViewportSize.Y)
            resolutionChanged:Fire(Vector2.new(game.Workspace.CurrentCamera.ViewportSize.X, game.Workspace.CurrentCamera.ViewportSize.Y))
        end
        
        --// Orientation changed
        local newOrientation = LibDeviceInfo.GetDeviceOrientation()
        if newOrientation ~= prevorientation then
            if newOrientation == LibDeviceInfo.Enum.DeviceOrientation.Portrait then
                orientationChanged:Fire(LibDeviceInfo.Enum.DeviceOrientation.Portrait) 
            elseif newOrientation == LibDeviceInfo.Enum.DeviceOrientation.Landscape then
                orientationChanged:Fire(LibDeviceInfo.Enum.DeviceOrientation.Landscape) 
            end
        end
    end)
end)

UserSettings().GameSettings.Changed:Connect(function()
	local quality = LibDeviceInfo.GetGraphicsQuality()
	if quality == prevquality then return end
    graphicsQualityChanged:Fire(quality)
end)

LibDeviceInfo.inputTypeChanged = inputChanged.Event
LibDeviceInfo.screenSizeChanged = resolutionChanged.Event
LibDeviceInfo.screenOrientationChanged = orientationChanged.Event
LibDeviceInfo.graphicsQualityChanged = graphicsQualityChanged.Event

return LibDeviceInfo</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="3">
      <Properties>
        <string name="Name">LibDiscordEmbedCreator</string>
        <string name="Source">--[[
File name: LibDiscordEmbedCreator.lua
Author: RadiatedExodus (RealEthanPlayz/RealEthanPlayzDev/ItzEthanPlayz_YT)
Reference links:
- https://discord.com/developers/docs/resources/channel#embed-object
- https://discord.com/developers/docs/resources/channel#embed-object-embed-field-structure
- https://discord.com/developers/docs/resources/channel#embed-object-embed-footer-structure
- https://discord.com/developers/docs/resources/channel#embed-object-embed-author-structure

NOTES:
- I do not have plans to implement image nor thumbnail types yet. I can implement them but I need to research Roblox's ToS further to see if they allow it.
--]]

local LibDiscordEmbedCreator = {}
LibDiscordEmbedCreator.__index = LibDiscordEmbedCreator
LibDiscordEmbedCreator.__metatable = "The metatable is locked"
LibDiscordEmbedCreator.ClassName = "LibDiscordEmbedCreator"

local LibDiscordEmbedFieldCreator = {}
LibDiscordEmbedFieldCreator.__index = LibDiscordEmbedFieldCreator
LibDiscordEmbedFieldCreator.__metatable = "The metatable is locked"

--// LibDiscordEmbedCreator class
--// function &lt;LibDiscordEmbedCreator> LibDiscordEmbedCreator:SetTitle(newtitle: string)
function LibDiscordEmbedCreator:SetTitle(newtitle: string)
    assert(typeof(newtitle) == "string", [[LibDiscordEmbedCreator: invalid argument #1 to 'SetTitle' (string expected, got ]]..typeof(newtitle)..[[)]])
    self.embedtable.title = tostring(newtitle)
    return self
end

--// function &lt;LibDiscordEmbedCreator> LibDiscordEmbedCreator:SetDescription(newdesc: string)
function LibDiscordEmbedCreator:SetDescription(newdesc: string)
    assert(typeof(newdesc) == "string", [[LibDiscordEmbedCreator: invalid argument #1 to 'SetDescription' (string expected, got ]]..typeof(newdesc)..[[)]])
    self.embedtable.description = tostring(newdesc)
    return self
end

--// function &lt;LibDiscordEmbedCreator> LibDiscordEmbedCreator:SetColor(newdesc: number)
function LibDiscordEmbedCreator:SetColor(newcolor: string)
    assert(typeof(newcolor) == "number", [[LibDiscordEmbedCreator: invalid argument #1 to 'SetColor' (number expected, got ]]..typeof(newcolor)..[[)]])
    self.embedtable.color = tostring(newcolor)
    return self
end

--// function &lt;LibDiscordEmbedCreator> LibDiscordEmbedCreator:AddField(fieldname: string, fieldvalue: string, inline: boolean)
function LibDiscordEmbedCreator:AddField(fieldname: string, fieldvalue: string, inline)
    assert(typeof(fieldname) == "string", [[LibDiscordEmbedCreator: invalid argument #1 to 'AddField' (string expected, got ]]..typeof(fieldname)..[[)]])
    assert(typeof(fieldvalue) == "string", [[LibDiscordEmbedCreator: invalid argument #2 to 'AddField' (string expected, got ]]..typeof(fieldvalue)..[[)]])
    local newfield = LibDiscordEmbedFieldCreator.new(fieldname, fieldvalue, inline or false)
    table.insert(self.embedtable.fields, #self.embedtable.fields + 1, newfield.fieldtable)
    return newfield
end

--// function &lt;LibDiscordEmbedCreator> LibDiscordEmbedCreator:SetFooterText(newfootername: string)
function LibDiscordEmbedCreator:SetFooterText(newfootertext: string)
    assert(typeof(newfootertext) == "string", [[LibDiscordEmbedCreator: invalid argument #1 to 'SetFooterText' (string expected, got ]]..typeof(newfootertext)..[[)]])
    self.embedtable.footer.text = tostring(newfootertext)
    return self
end

--// function &lt;LibDiscordEmbedCreator> LibDiscordEmbedCreator:SetFooterIconURL(newfootername: string)
function LibDiscordEmbedCreator:SetFooterIconURL(newiconurl: string)
    assert(typeof(newiconurl) == "string", [[LibDiscordEmbedCreator: invalid argument #1 to 'SetFooterIconURL' (string expected, got ]]..typeof(newiconurl)..[[)]])
    self.embedtable.footer.icon_url = tostring(newiconurl)
    return self
end

--// LibDiscordEmbedFieldCreator class
--// [internal class usage]
function LibDiscordEmbedFieldCreator.new(name: string, value: string, inline: boolean)
    local self = setmetatable({}, LibDiscordEmbedFieldCreator)

    self.fieldtable = {
        name = name;
        value = value;
        inline = inline;
    }

    return self
end

--// function &lt;LibDiscordEmbedFieldCreator> LibDiscordEmbedFieldCreator:SetFieldName(newname: string)
function LibDiscordEmbedFieldCreator:SetFieldName(newname: string)
    assert(typeof(newname) == "string", [[LibDiscordEmbedFieldCreator: invalid argument #1 to 'SetFieldName' (string expected, got ]]..typeof(newname)..[[)]])
    self.fieldtable.name = tostring(newname)
    return self
end

--// function &lt;LibDiscordEmbedFieldCreator> LibDiscordEmbedFieldCreator:SetFieldValue(newvalue: string)
function LibDiscordEmbedFieldCreator:SetFieldValue(newvalue: string)
    assert(typeof(newvalue) == "string", [[LibDiscordEmbedFieldCreator: invalid argument #1 to 'SetFieldValue' (string expected, got ]]..typeof(newvalue)..[[)]])
    self.fieldtable.value = tostring(newvalue)
    return self
end

--// function &lt;LibDiscordEmbedFieldCreator> LibDiscordEmbedFieldCreator:SetFieldInline(newinline: boolean)
function LibDiscordEmbedFieldCreator:SetFieldInline(newinline: boolean)
    assert(typeof(newinline) == "boolean", [[LibDiscordEmbedFieldCreator: invalid argument #1 to 'SetFieldInline' (boolean expected, got ]]..typeof(newinline)..[[)]])
    self.fieldtable.inline = newinline
    return self
end

return {
    --// [constructor] function new()
    new = function()
        local self = setmetatable({}, LibDiscordEmbedCreator)

        self.embedtable = {
            title = "";
            description = "";
            color = 0x00000;
            fields = {};
            footer = { text = ""; icon_url = ""; };
        }

        return self
    end
}</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="4">
      <Properties>
        <string name="Name">LibDiscordWebhookSender</string>
        <string name="Source">--[[
File name: LibDiscordWebhookSender.lua
Author: RadiatedExodus (RealEthanPlayz/RealEthanPlayzDev/ItzEthanPlayz_YT)
--]]

local serv = {
    HttpService = game:GetService("HttpService");
}

local LibDiscordWebhookSender = {}
LibDiscordWebhookSender.__index = LibDiscordWebhookSender
LibDiscordWebhookSender.__metatable = "The metatable is locked"
LibDiscordWebhookSender.ClassName = "LibDiscordWebhookSender"

local function CheckHttpEnabled()
    return pcall(function()
        serv.HttpService:GetAsync("https://www.google.com")
        return true
    end)
end

--// function &lt;boolean> LibDiscordWebhookSender:SendData()
function LibDiscordWebhookSender:SendData()
    --// https://developer.roblox.com/en-us/api-reference/function/HttpService/RequestAsync
    assert(CheckHttpEnabled(), "LibDiscordWebhookSender: Http requests are not enabled. Enable via game settings")
    local sendsuccess, sendattempt, sendresult = false, 0, nil
    sendsuccess, sendresult = pcall(function()
        return serv.HttpService:RequestAsync({
            Url = tostring(self.webhookurl);
            Method = "POST";
            Headers = { ["Content-Type"] = "application/json" };
            Body = serv.HttpService:JSONEncode(self.webhookluatabledata)
        })
    end)

    if sendsuccess and sendresult.Success == true then
        return true
    else
        return error("LibDiscordWebhookSender: unable to send webhook data\nStatusCode: "..sendresult.StatusCode.."\nStatusMessage: "..sendresult.StatusMessage, 2)
    end
end

--// function &lt;LibDiscordWebhookSender> LibDiscordWebhookSender:SetUsername(newname: string)
function LibDiscordWebhookSender:SetUsername(newname: string)
    assert(typeof(newname) == "string", [[LibDiscordWebhookSender: invalid argument #1 to 'SetUsername' (string expected, got ]]..typeof(newname)..[[)]])
    self.webhookluatabledata.username = tostring(newname)
    return self
end

--// function &lt;LibDiscordWebhookSender> LibDiscordWebhookSender:SetAvatarUrl(newavatarurl: string)
function LibDiscordWebhookSender:SetAvatarUrl(newavatarurl: string)
    assert(typeof(newavatarurl) == "string", [[LibDiscordWebhookSender: invalid argument #1 to 'SetAvatarUrl' (string expected, got ]]..typeof(newavatarurl)..[[)]])
    self.webhookluatabledata.avatar_url = tostring(newavatarurl)
    return self
end

--// function &lt;LibDiscordWebhookSender> LibDiscordWebhookSender:SetAvatarUrl(newavatarurl: string)
function LibDiscordWebhookSender:SetContent(newcontent: string)
    assert(typeof(newcontent) == "string", [[LibDiscordWebhookSender: invalid argument #1 to 'SetContent' (string expected, got ]]..typeof(newcontent)..[[)]])
    self.webhookluatabledata.content = tostring(newcontent)
    return self
end

--// function &lt;LibDiscordWebhookSender> LibDiscordWebhookSender:AddEmbed(newembed: table)
function LibDiscordWebhookSender:AddEmbed(newembed: table)
    assert(typeof(newembed) == "table", [[LibDiscordWebhookSender: invalid argument #1 to 'AddEmbed' (table expected, got ]]..typeof(newembed)..[[)]])
    if newembed["ClassName"] == "LibDiscordEmbedCreator" then
        table.insert(self.webhookluatabledata.embeds, #self.webhookluatabledata.embeds + 1, newembed.embedtable)
    else
        table.insert(self.webhookluatabledata.embeds, #self.webhookluatabledata.embeds + 1, newembed)
    end
    return self
end

return {
    --// [constructor] function &lt;LibDiscordWebhookSender> new(webhookurl: string)
    new = function(webhookurl: string)
        assert(typeof(webhookurl) == "string", [[LibDiscordWebhookSender: invalid argument #1 to 'new' (string expected, got ]]..typeof(webhookurl)..[[)]])
        local self = setmetatable({}, LibDiscordWebhookSender)

        self.webhookurl = webhookurl
        self.webhookluatabledata = {
            username = ""; --// Webhook username
            avatar_url = ""; --// Webhook avatar
            content = ""; --// Webhook message (max 2000 characters as defined by Discord)
            embeds = {}; --// Webhook embeds
        }

        return self
    end
}</string>
      </Properties>
    </Item>
    <Item class="ModuleScript" referent="5">
      <Properties>
        <string name="Name">LibInstUtil</string>
        <string name="Source">--[[
File name: LibInstUtil.lua
Author: RadiatedExodus (RealEthanPlayz/RealEthanPlayzDev/ItzEthanPlayz_YT)
--]]

local LibInstUtil = {}

--// function &lt;number> LibInstUtil.CalculateTotalMass(inst: Instance)
function LibInstUtil.CalculateTotalMass(inst: Instance): number
    assert(typeof(inst) == "Instance", [[LibInstUtil: invalid argument #2 to 'Create' (Instance expected, got ]]..typeof(inst)..[[)]])
    if inst:IsA("BasePart") then
        return inst.Mass
    elseif inst:IsA("Model") then
        local masscount = 0
        for _, v in pairs(inst:GetDescendants()) do
            if v:IsA("BasePart") then
                masscount += v.Mass
            end
        end
        return masscount
    end
end

--// function &lt;Instance> LibInstUtil.Create(classname: string, data: table)
function LibInstUtil.Create(classname: string, data: table): Instance
    assert(typeof(classname) == "string", [[LibInstUtil: invalid argument #1 to 'Create' (string expected, got ]]..typeof(classname)..[[)]])
    assert(typeof(data) == "table", [[LibInstUtil: invalid argument #2 to 'Create' (table expected, got ]]..typeof(classname)..[[)]])
    local newinst = Instance.new(classname)
    local parentpropertyavailable = nil
    for property, value in pairs(data) do
        if not property == "Parent" then
            newinst[property] = value
        else
            parentpropertyavailable = value
        end
    end
    if parentpropertyavailable then newinst.Parent = parentpropertyavailable end
    parentpropertyavailable = nil
    return newinst
end

--// function &lt;void> LibInstUtil.SetAllBasePartTransparency(inst: Instance, newtransparency: number)
function LibInstUtil.SetAllBasePartTransparency(inst: Instance, newtransparency: number)
    assert(typeof(inst) == "Instance", [[LibInstUtil: invalid argument #1 to 'SetAllBasePartTransparency' (Instance expected, got ]]..typeof(inst)..[[)]])
    assert(typeof(newtransparency) == "Instance", [[LibInstUtil: invalid argument #2 to 'SetAllBasePartTransparency' (number expected, got ]]..typeof(newtransparency)..[[)]])
    if inst:IsA("BasePart") then
        inst.Transparency = newtransparency
    else
        for _, v in pairs(inst:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Transparency = newtransparency
            end
        end
    end
    return
end

return LibInstUtil</string>
      </Properties>
    </Item>
  </Item>
</roblox>